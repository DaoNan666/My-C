#define _CRT_SECURE_NO_WARNINGS


//题目：古典问题（兔子生崽）：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？（输出前40个月即可）
//
//程序分析：兔子的规律为数列1, 1, 2, 3, 5, 8, 13, 21....，即下个月是上两个月之和（从第三个月开始）。
//#include <stdio.h>
//int main() {
//	long int a = 1;
//	long int b = 1;
//	long int i;
//	for (i = 1; i <= 20; i++) {
//		// 循环一次输出两个月的值
//		printf("%12d%12d", a, b);
//		// 控制每行4个输出
//		if (i % 2 == 0)  printf("\n");
//		// 此题规律为下月为前两个月的和（从第三个月开始）
//		a = a + b;
//		b = a + b;
//	}
//	return 0;
//}


//题目：判断 101 到 200 之间的素数。
//
//程序分析：一个数除了1和本身之外，
// 从2开始，若期间有能整除这期间的数，说明i不是素数，
// 若没有可以整除的数，说明i是素数
//  方法一：
//#include <stdio.h>
//int main() {
//	//定义i用来控制101-200
//	int i, j;
//	//count作为计数器，用来后面换行美观
//	int count = 0;
//
//	for (i = 101; i <= 200; i++) {
//		//让j从2开始，看是否能被i整除
//		for (j = 2; j < i; j++) {
//			//若j能被i整除，则跳出循环
//			if (i % j == 0)
//				break;
//		}
//		//循环提前跳出，若j<i说明在2-j之间，i有可整除的数
//		if (j >= i) {
//			count++;
//			printf("%d ", i);
//			//count作为计数器，每5个数换行
//			if (count % 5 == 0)
//				printf("\n");
//		}
//	}
//	return 0;
//}


//// 方法二：
//程序分析：判断素数的方法：用一个数分别去除 2 到 sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。
//#include <stdio.h>
//#include <math.h>
//
//int main() {
//	int i, j, k;
//	for (i = 101; i <= 200; i++) {
//		k = sqrt(i);
//		for (j = 2; j <= k; j++) {
//			if (i % j == 0)
//				break;
//		}
//		if (j > k) {
//			printf("%d ", i);
//		}
//	}
//	return 0;
//}
//
//

//
//题目：打印出所有的"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该数 本身。例如：153是一个"水仙花数"，因为153 = 1的三次方＋5的三次方＋3的三次方。
//
//程序分析：利用for循环控制100 - 999个数，每个数分解出个位，十位，百位
//#include <stdio.h>
////水仙花数为三位数，这里最大求到1000
//#define Max 1000
//
//int main() {
//	int i, x, y, z;
//	for (i = 100; i <= Max; i++) {
//		x = i%10;  //  分解出三位数的个位
//		y = i/10%10; // 分解出三位数的十位
//		z = i / 100 % 10;//分解三位数的百位
//		//判断i是否为分解出的各个位的立方和
//		if((i == x * x * x + y * y * y + z * z * z))
//			printf("%d ",i);
//	}
//	return 0;
//}


//题目：将一个正整数分解质因数。例如：输入90, 打印出90 = 2 * 3 * 3 * 5。
//
//程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：
//
//(1)如果这个质数恰等于（小于的时候，继续执行循环）n，则说明分解质因数的过程已经结束，另外 打印出即可。
//(2)但n能被k整除，则应打印出k的值，并用n除以k的商, 作为新的正整数n.重复执行第二步。
//(3)如果n不能被k整除，则用k + 1作为k的值, 重复执行第一步。
// 
// 
//#include <stdio.h>
//int main() {
//	int n, i;
//	printf("请输入一个整数：");
//	scanf("%d", &n);
//	printf("%d = ", n);
//	// i从2-n之间循环
//	for (i = 2; i <= n; i++) {
//		//若n能够整除i，说明i为一个最小质数
//		//若不能整除，则将新的n再次循环，直到i>n结束
//		while (n % i == 0) {
//			printf("%d", i);
//			//用n除以i的商,作为新的正整数n.重复执行
//			n = n / i;
//
//			if (n != 1)
//				printf(" * ");
//		}
//	}
//	//printf("\n");
//	return 0;
//}



//题目：利用条件运算符的嵌套来完成此题：学习成绩 >= 90分的同学用A表示，60 - 89分之间的用B表示，60分以下的用C表示。
//
//程序分析：(a > b) ? a : b这是条件运算符的基本例子。
//
//#include <stdio.h>
//int main() {
//	int score;
//	char a;
//	printf("请输入成绩：");
//	scanf("%d", &score);
//	//条件运算符：
//	// (a>b)?a:b   若a > b为真，则返回a，否则返回b
//	a = (score >= 90) ? 'A' : ((score >= 60) ? 'B' : 'C');
//	printf("%c\n", a);
//	return 0;
//}


//题目：输入两个正整数m和n，求其最大公约数和最小公倍数。
//
//程序分析：
//
//（1）最小公倍数 = 输入的两个数之积除于它们的最大公约数，关键是求出最大公约数；
//
//（2）求最大公约数用辗转相除法（又名欧几里德算法）
//
//#include <stdio.h>
//
//int main() {
//	int a, b, temp;
//	int r, n;
//	printf("请输入两个正整数：");
//	scanf("%d%d", &a, &b);
//	// 使输入的两个数最大值赋给a
//	if (a < b) {
//		temp = a;
//		a = b;
//		b = temp;
//	}
//	// r为a%b取余运算
//	r = a % b;
//	n = a * b;
// // 辗转相除法
//	while (r != 0) {
//		
//		a = b;
//		b = r;
//		r = a % b;
//	}
//	//最小公倍数 = 输入的两个数之积 除于 它们的最大公约数
//	printf("这两个数的最大公约数是%d，最小公倍数是%d\n", b, n / b);
//	return 0;
//}
//


//题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。
//
//程序分析：利用while语句, 条件为输入的字符不为'\n'

//#include <stdio.h>
//
//int main() {
//	char a;
//	int letter = 0, space = 0, digit = 0, others = 0;
//	printf("请输入一行字符：\n");
//	while ((a = getchar()) != '\n') {
//		if ((a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z'))
//			letter++;
//		else if (a >= '0' && a <= '9')
//			digit++;
//		else if (a == ' ')
//			space++;
//		else
//			others++;
//	}
//	printf("字母=%d,数字=%d,空格=%d,其他=%d\n", letter, digit, space, others);
//	return 0;
//}


//题目：求s = a + aa + aaa + aaaa + aa...a的值，其中a是一个数字。
//例如2 + 22 + 222 + 2222 + 22222(此时共有5个数相加)，几个数相加有键盘控制。
//#include <stdio.h>
//int main() {
//	int s = 0, a, n, t;
//	printf("请输入一个要加的数字和要加的项数：");
//	scanf("%d%d", &a, &n);
//	t = a;
//	while (n > 0) {
//		// 如a为2，则 s = 0 + 2 =2
//		s = s + t;
//		//a = 2 * 10 = 20
//		a = a * 10;
//		// t = 2 +20 = 22
//		t = t + a;
//		n--;
//	}
//	printf("a+aa....=%d\n", s);
//	return 0;
//}
//
//题目：一个数如果恰好等于它的因子之和，这个数就称为"完数"。
//例如6 = 1＋2＋3.编程找出1000以内的所有完数
//方法一：
//#include <stdio.h>
//#define Max 1000
//int main(){
//	int i, j, k, n, sum;
//	int a[256];
//	for (i = 2; i <= Max; i++) {
//		sum = a[0] = 1;
//		k = 0;
//		for (j = 2; j <= (i / 2); j++) {
//			if (i % j == 0) {
//				sum = sum + j;
//				a[++k] = j;
//			}
//		}
//		if (i == sum) {
//			printf("%d=%d", i, a[0]);
//			for (n = 1; n <= k; n++)
//				printf("+%d", a[n]);
//			printf("\n");
//		}
//	}
//	return 0;
//}

//方法二：
//#include <stdio.h>
//#define Max 1000
//
//int main()
//{
//    int sum, x, i;
//    for (x = 1; x <= Max; x++) {
//        sum = 0;
//        //一个数的因子，最大为该数的一半
//        for (i = 1; i <= x / 2; i++)
//            if (x % i == 0)
//        // 将因子之和赋给sum
//                sum += i;
//        //若因子之和等于该数，则输出
//        if (sum == x)
//            printf("%d\n", x);
//    }
//    return 0;
//}


//题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；
//再落下，求它在第10次落地时，共经过多少米？第10次反弹多高?

//#include <stdio.h>
//int main() {
//	float h, s;
//	h = s = 100;
//	// 第一次反弹后的高度
//	h = h / 2;
//	for (int i = 2; i <= 10; i++) {
//		// 弹起来 落下 一共2次 
//		s = s + 2 * h;
//		h = h / 2;
//	}
//	printf("第10次落地时，共经过%lf米，第10次反弹%lf米\n", s, h);
//	return 0;
//}

//题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个
//第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下
//的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。
//
//程序分析：采取逆向思维的方法，从后往前推断。
//
//#include <stdio.h>
//
//int main() {
//	// a为第一天桃子，b为第二天桃子
//	//则 b=a/2 -1
//	//所以 a = （b+1）*2
//	int day, a = 0, b;
//	day = 9;
//	// b为第10天只剩下的一个桃子
//	b = 1;
//	while (day > 0) {
//		a = (b + 1) * 2;
//		b = a;
//		day--;
//	}
//	printf("桃子一共有%d个\n", a);
//	return 0;
//}